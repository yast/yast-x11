/**
 * File:	autoyast/modules/AutoinstX11.ycp
 * Module:	Auto-Installation
 * Summary:	X11
 * Authors:	Marcus Sch√§fer <ms@suse.de>
 *
 */
{ // begin
module "AutoinstX11";

textdomain "x11";
import "Summary";
import "Directory";
import "XLib";
import "Arch";
import "Mode";

//=======================================
// Globals
//---------------------------------------
global map x11 = $[];
global map monitor = $[];
global map display = $[];
global string current_vendor = "";
global string current_model  = "";
global boolean modified = false;

global list vendors = [];
global list models  = [];
global list<map> all_monitors = [];


//=======================================
// autoyastX11Allowed
//
// disable autoYaST functionality (currently in Read and Export)
//---------------------------------------
global boolean autoyastX11Allowed ()
{
	// on Itanium during installation/update/repair/live_installation no X11 cloning should be performed (bnc#439612) (bnc#449147)
	if ( Arch::ia64()  &&   ! contains(["installation", "update", "repair", "live_installation"], Mode::mode()) )
	{
		y2warning("On Itanium (ia64) during installation no cloning of the X11 configuration is supported.");
		y2warning("X11 will return an empty configuration now.");
		y2warning("You can however create a clone config including X11 within the running system.");
		return false;
	}

	return true;
}


//=======================================
// SetModified
//---------------------------------------
global define void SetModified () {
	modified = true;
}

//=======================================
// GetModified
//---------------------------------------
global define boolean GetModified () {
	return modified;
}

//=======================================
// Import
//---------------------------------------
global define boolean Import (map settings) {
	x11 = settings;
	monitor = x11["monitor"]:$[];
	display = monitor["display"]:$[];
	current_vendor = monitor["monitor_vendor"]:"" ;
	current_model  = monitor["monitor_device"]:"" ;
	return true;
}

//=======================================
// Export
//---------------------------------------
global define map Export () {
	if ( ! autoyastX11Allowed() ) { return $[]; }

	monitor["display"] = display;
	monitor["monitor_device"] = current_model;
	monitor["monitor_vendor"] = current_vendor;
	x11["monitor"] = monitor;
	return x11;
}

//=======================================
// Summary
//---------------------------------------
global define string Summary() {
	string summary = "";
	map m = x11["monitor"]:$[];
	map d = m["display"]:$[];
	string my_current_vendor = m["monitor_vendor"]:"";
	string my_current_model  = m["monitor_device"]:"";
	string my_monitor =  Summary::NotConfigured();
	if (size(my_current_vendor) > 0) {
		my_monitor = sformat("%1   %2", my_current_vendor, my_current_model);
	}
	string horizontal = sformat("%1 - %2",d["min_hsync"]:0 , d["max_hsync"]:0);
	string vertical = sformat("%1 - %2",  d["min_vsync"]:0 , d["max_vsync"]:0);
	string nc = Summary::NotConfigured ();
	string depth = sformat ("%1",
		(x11["color_depth"]:-1 != -1) ? x11["color_depth"]:-1 : nc
	);
	summary = Summary::AddHeader (summary, _("Enable 3D Support If Possible"));
	summary = Summary::AddLine   (summary,
		(x11["enable_3d"]:false) ? _("Yes") : nc
	);
	summary = Summary::AddHeader (summary, _("Color Depth"));
	summary = Summary::AddLine   (summary, depth );
	summary = Summary::AddHeader (summary, _("Resolution"));
	summary = Summary::AddLine   (summary,
		(x11["resolution"]:"" != "") ? x11["resolution"]:"" : nc
	);
	summary = Summary::AddHeader (summary, _("Display Manager"));
	summary = Summary::AddLine   (summary,
		(x11["display_manager"]:"" != "") ? x11["display_manager"]:"" : nc
	);
	summary = Summary::AddHeader (summary, _("Window Manager"));
	summary = Summary::AddLine   (summary,
		(x11["window_manager"]:"" != "") ? x11["window_manager"]:"" : nc
	);
	summary = Summary::AddHeader (summary, _("Monitor"));
	summary = Summary::AddLine   (summary, my_monitor);
	summary = Summary::AddHeader (summary, _("Horizontal frequency"));
	summary = Summary::AddLine   (summary, horizontal);
	summary = Summary::AddHeader (summary, _("Vertical frequency"));
	summary = Summary::AddLine   (summary, vertical);

    return summary;
}

//=======================================
// readMonitorDB
//---------------------------------------
global define void readMonitorDB() {
	string static_monitors  = Directory::datadir + "/monitors.ycp";
	all_monitors = (list<map>)SCR::Read( .target.ycp, [ static_monitors, [] ]);
	vendors = toset(
		maplist( map monitor, all_monitors,``( monitor["vendor"]:"" ))
	);
}

//=======================================
// Read
//---------------------------------------
global define boolean Read() {
	if ( ! autoyastX11Allowed() ) { return true; }

	x11["display_manager"] = (string) eval (SCR::Read(
		.sysconfig.displaymanager.DISPLAYMANAGER
	));
	x11["window_manager"] = (string) eval (SCR::Read(
		.sysconfig.windowmanager.DEFAULT_WM
	));
	// x11["enable_3d"] = false;
	// switch default of 3D to be enabled (bnc#594064)
	x11["enable_3d"] = true;

	if (! (boolean)XLib::isInitialized()) {
		y2milestone ("X11-Auto: Loading library cache...");
		XLib::loadApplication();
	}
	current_vendor = (string) XLib::getMonitorVendor();
	current_model  = (string) XLib::getMonitorModel();
    // store this value with type integer in the map so it gets exported
    // correctly to the autoyast profile (bnc#418648).
    x11["color_depth"] = tointeger(XLib::getActiveColorDepth());
	x11["resolution"]  = (string) XLib::getActiveResolutionString();
	display["min_hsync"] = tointeger(XLib::getHsyncMin());
	display["max_hsync"] = tointeger(XLib::getHsyncMax());
	display["min_vsync"] = tointeger(XLib::getVsyncMin());
	display["max_vsync"] = tointeger(XLib::getVsyncMax());
	return true;
}

//=======================================
// Write
//---------------------------------------
global define boolean Write() {
	if (! (boolean)XLib::isInitialized()) {
		y2milestone ("X11-Auto: Loading library cache...");
		XLib::loadApplication();
	}
	string displayManager = x11["display_manager"]:"";
	string windowManager  = x11["window_manager"]:"";
	if (size(displayManager) > 0) {
		y2milestone("X11-Auto: setup display manager <%1>",displayManager);
		SCR::Write (.sysconfig.displaymanager.DISPLAYMANAGER, displayManager);
		SCR::Write (.sysconfig.displaymanager, nil);
	}
	if (size(windowManager) > 0) {
		y2milestone("X11-Auto: setup window manager <%1>",windowManager);
		SCR::Write (.sysconfig.windowmanager.DEFAULT_WM, windowManager);
		SCR::Write (.sysconfig.windowmanager, nil);
	}

	// Use hsync range up to 94 kHz since apparently on modern machines
	// hwinfo/libhd always fails to detect the monitor and a limit to 60kHz
	// breaks resolutions used nowadays. This should be safe since you
	// can't break modern monitors that easy any longer. Also the mode
	// chosen depends on being detected/supported by KMS in most cases
	// now anyway.
	integer hstart = tointeger(display["min_hsync"]:31);
	integer hstop  = tointeger(display["max_hsync"]:94);
	integer vstart = tointeger(display["min_vsync"]:50);
	integer vstop  = tointeger(display["max_vsync"]:75);
	y2milestone("X11-Auto: setup monitor <%1:%2>",current_vendor,current_model);
	XLib::setMonitorCDB ( [current_vendor,current_model] );
	XLib::setHsyncRange (hstart,hstop);
	XLib::setVsyncRange (vstart,vstop);

	string resolution = x11["resolution"]:"800x600 (SVGA)";
	y2milestone("X11-Auto: setup resolution <%1>",resolution);
	XLib::setResolution ( resolution );

	// convert value to integer (bnc#307967)
	// made obsolete by fix for (bnc#418648), cast the value to be sure it is integer
	integer colors = (integer) x11["color_depth"]:16;

	// do not set the DefaultColorDepth when using fbdev (bnc#735130)
	if ( ! XLib::isFbdevBased() ) {
	    y2milestone("X11-Auto: setup color depth <%1>",colors);
	    XLib::setDefaultColorDepth ( tostring(colors) );
	}

	boolean enable3D = x11["enable_3d"]:false;
	y2milestone("X11-Auto: setup 3D <%1>",enable3D);
	boolean has3D = XLib::hasOpenGLFeatures();
	if ((enable3D) && (has3D)) {
		XLib::activate3D();

	} else {
		XLib::deactivate3D();
	}
	boolean status = XLib::writeConfiguration();
	return  status;
}
} // end
